// Mapping the Glacier Bay landslide using Sentinel-1 and Sentinel-2
// http://www.cesbio.ups-tlse.fr/multitemp/?p=8027

// location
var pt = ee.Geometry.Point(-136.886792,58.773959); // Glacier Bay

// Load Sentinel-2 image acquired on 11-Jul-2016
var S2after=ee.Image('COPERNICUS/S2/20160711T202312_20160712T000141_T08VLL');

// S2 collection before
var S2collbefore =  ee.ImageCollection('COPERNICUS/S2').filterBounds(pt)
.filterDate('2016-06-01', '2016-06-20'); // June 21 is too cloudy
var S2before = ee.Image(S2collbefore.sort('system:time_start',false).first());

// print acquisition date of S2 pre-event image
var S2datebefore=ee.Date(S2before.get('system:time_start'));
print(S2datebefore.format('yyyy-MM-dd hh:mm'));

// compute difference in green band
var diff_S2 = S2after.subtract(S2before).select('B3');

// S2 vizualisation parameter
var S2viztrue = {'bands':'B4,B3,B2', 'min': 0, 'max': 10000, 'gamma':1.5}; 
var S2vizsnow = {'bands':'B11,B4,B3', 'min': 0, 'max': 4000}; 
var S2vizdiff = {'bands':'B3', 'min': -8000, 'max': 0}; 

// Load Sentinel-1 C-band SAR Ground Range collection (log scaling, VV co-polar)
var S1collection =  ee.ImageCollection('COPERNICUS/S1_GRD').filterBounds(pt)
.filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))
.select('VV')
.filter(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'));

// Filter by date
var S1collbefore = S1collection.filterDate('2016-06-01', '2016-06-28');
var S1collafter = S1collection.filterDate('2016-06-28', '2016-07-01');
var S1before = ee.Image(S1collbefore.sort('system:time_start',false).first());
var S1after = ee.Image(S1collafter.sort('system:time_start',true).first());

// print acquisition date of S1 pre- and post-event images
var S1datebefore=ee.Date(S1before.get('system:time_start'));
var S1dateafter=ee.Date(S1after.get('system:time_start'));
print(S1datebefore.format('yyyy-MM-dd hh:mm'));
print(S1dateafter.format('yyyy-MM-dd hh:mm'));

// Threshold S1 smoothed radar intensities to identify "land slide" areas.
var DIFF_UPPER_THRESHOLD_Lee = 7; 
var diff_smoothed_Lee = toDB(RefinedLee(toNatural(S1after)))
.subtract(toDB(RefinedLee(toNatural(S1before))));
var diff_thresholded_Lee = diff_smoothed_Lee.gt(DIFF_UPPER_THRESHOLD_Lee);

// Threshold S2 TOA reflectance differences to identify "land slide" areas.
var DIFF_UPPER_THRESHOLD_S2 = -5000; 
var diff_thresholded_S2 = diff_S2.lt(DIFF_UPPER_THRESHOLD_S2);

// vectorize S2
var S2zones = diff_thresholded_S2.updateMask(diff_thresholded_S2);
var S2vectors = S2zones.addBands(diff_thresholded_S2).reduceToVectors({
  geometry: ROI,
  crs: diff_thresholded_S2.projection(),
  scale: 100,
  geometryType: 'polygon',
  eightConnected: true,
  labelProperty: 'zone',
  reducer: ee.Reducer.count()
});
var S2v=ee.Feature(S2vectors.sort('count',false).first());
// print area in sq. km
print(S2v.area(10).divide(1000 * 1000));

// vectorize S1
var S1zones = diff_thresholded_Lee.updateMask(diff_thresholded_Lee);
var S1vectors = S1zones.addBands(diff_smoothed_Lee).reduceToVectors({
  geometry: ROI,
  crs: diff_thresholded_Lee.projection(),
  scale: 20,
  geometryType: 'polygon',
  eightConnected: true,
  labelProperty: 'zone',
  reducer: ee.Reducer.count()
});
var S1v=ee.Feature(S1vectors.sort('count',false).first());
// print area in sq. km
print(S1v.area(10).divide(1000 * 1000));

// Display map
Map.centerObject(pt, 10);
Map.addLayer(S2before, S2viztrue, 'S2 before landslide',0);
Map.addLayer(S2after, S2viztrue, 'S2 after landslide',1);
Map.addLayer(diff_S2, S2vizdiff, 'S2 diff',0);
Map.addLayer(S1before, {min:-30,max:10}, 'S1 before landslide',0);
Map.addLayer(S1after, {min:-30,max:10}, 'S1 after landslide',0);
Map.addLayer(diff_smoothed_Lee, {min:-10,max:10}, 'S1 diff smoothed', 0); 
Map.addLayer(S1zones, {palette:"0000FF"},'landslide areas (S1)',0);
Map.addLayer(S1v, {}, 'S1 landslide polygon',0);
Map.addLayer(S2zones, {palette:"0000FF"},'landslide areas (S2)',1);
Map.addLayer(S2v, {}, 'S2 landslide polygon',1);

// ************* Functions ************* 

// Functions to convert from/to dB
function toNatural(img) {
  return ee.Image(10.0).pow(img.select(0).divide(10.0));
}

function toDB(img) {
  return ee.Image(img).log10().multiply(10.0);
}

// The RL speckle filter from https://code.earthengine.google.com/2ef38463ebaf5ae133a478f173fd0ab5
// by Guido Lemoine
function RefinedLee(img) {
  // img must be in natural units, i.e. not in dB!
  // Set up 3x3 kernels 
  var weights3 = ee.List.repeat(ee.List.repeat(1,3),3);
  var kernel3 = ee.Kernel.fixed(3,3, weights3, 1, 1, false);

  var mean3 = img.reduceNeighborhood(ee.Reducer.mean(), kernel3);
  var variance3 = img.reduceNeighborhood(ee.Reducer.variance(), kernel3);

  // Use a sample of the 3x3 windows inside a 7x7 windows to determine gradients and directions
  var sample_weights = ee.List([[0,0,0,0,0,0,0], [0,1,0,1,0,1,0],[0,0,0,0,0,0,0], [0,1,0,1,0,1,0], [0,0,0,0,0,0,0], [0,1,0,1,0,1,0],[0,0,0,0,0,0,0]]);

  var sample_kernel = ee.Kernel.fixed(7,7, sample_weights, 3,3, false);

  // Calculate mean and variance for the sampled windows and store as 9 bands
  var sample_mean = mean3.neighborhoodToBands(sample_kernel); 
  var sample_var = variance3.neighborhoodToBands(sample_kernel);

  // Determine the 4 gradients for the sampled windows
  var gradients = sample_mean.select(1).subtract(sample_mean.select(7)).abs();
  gradients = gradients.addBands(sample_mean.select(6).subtract(sample_mean.select(2)).abs());
  gradients = gradients.addBands(sample_mean.select(3).subtract(sample_mean.select(5)).abs());
  gradients = gradients.addBands(sample_mean.select(0).subtract(sample_mean.select(8)).abs());

  // And find the maximum gradient amongst gradient bands
  var max_gradient = gradients.reduce(ee.Reducer.max());

  // Create a mask for band pixels that are the maximum gradient
  var gradmask = gradients.eq(max_gradient);

  // duplicate gradmask bands: each gradient represents 2 directions
  gradmask = gradmask.addBands(gradmask);

  // Determine the 8 directions
  var directions = sample_mean.select(1).subtract(sample_mean.select(4)).gt(sample_mean.select(4).subtract(sample_mean.select(7))).multiply(1);
  directions = directions.addBands(sample_mean.select(6).subtract(sample_mean.select(4)).gt(sample_mean.select(4).subtract(sample_mean.select(2))).multiply(2));
  directions = directions.addBands(sample_mean.select(3).subtract(sample_mean.select(4)).gt(sample_mean.select(4).subtract(sample_mean.select(5))).multiply(3));
  directions = directions.addBands(sample_mean.select(0).subtract(sample_mean.select(4)).gt(sample_mean.select(4).subtract(sample_mean.select(8))).multiply(4));
  // The next 4 are the not() of the previous 4
  directions = directions.addBands(directions.select(0).not().multiply(5));
  directions = directions.addBands(directions.select(1).not().multiply(6));
  directions = directions.addBands(directions.select(2).not().multiply(7));
  directions = directions.addBands(directions.select(3).not().multiply(8));

  // Mask all values that are not 1-8
  directions = directions.updateMask(gradmask);

  // "collapse" the stack into a singe band image (due to masking, each pixel has just one value (1-8) in it's directional band, and is otherwise masked)
  directions = directions.reduce(ee.Reducer.sum());  

  //var pal = ['ffffff','ff0000','ffff00', '00ff00', '00ffff', '0000ff', 'ff00ff', '000000'];
  //Map.addLayer(directions.reduce(ee.Reducer.sum()), {min:1, max:8, palette: pal}, 'Directions', false);

  var sample_stats = sample_var.divide(sample_mean.multiply(sample_mean));

  // Calculate localNoiseVariance
  var sigmaV = sample_stats.toArray().arraySort().arraySlice(0,0,5).arrayReduce(ee.Reducer.mean(), [0]);

  // Set up the 7*7 kernels for directional statistics
  var rect_weights = ee.List.repeat(ee.List.repeat(0,7),3).cat(ee.List.repeat(ee.List.repeat(1,7),4));

  var diag_weights = ee.List([[1,0,0,0,0,0,0], [1,1,0,0,0,0,0], [1,1,1,0,0,0,0], 
    [1,1,1,1,0,0,0], [1,1,1,1,1,0,0], [1,1,1,1,1,1,0], [1,1,1,1,1,1,1]]);

  var rect_kernel = ee.Kernel.fixed(7,7, rect_weights, 3, 3, false);
  var diag_kernel = ee.Kernel.fixed(7,7, diag_weights, 3, 3, false);

  // Create stacks for mean and variance using the original kernels. Mask with relevant direction.
  var dir_mean = img.reduceNeighborhood(ee.Reducer.mean(), rect_kernel).updateMask(directions.eq(1));
  var dir_var = img.reduceNeighborhood(ee.Reducer.variance(), rect_kernel).updateMask(directions.eq(1));

  dir_mean = dir_mean.addBands(img.reduceNeighborhood(ee.Reducer.mean(), diag_kernel).updateMask(directions.eq(2)));
  dir_var = dir_var.addBands(img.reduceNeighborhood(ee.Reducer.variance(), diag_kernel).updateMask(directions.eq(2)));

  // and add the bands for rotated kernels
  for (var i=1; i<4; i++) {
    dir_mean = dir_mean.addBands(img.reduceNeighborhood(ee.Reducer.mean(), rect_kernel.rotate(i)).updateMask(directions.eq(2*i+1)));
    dir_var = dir_var.addBands(img.reduceNeighborhood(ee.Reducer.variance(), rect_kernel.rotate(i)).updateMask(directions.eq(2*i+1)));
    dir_mean = dir_mean.addBands(img.reduceNeighborhood(ee.Reducer.mean(), diag_kernel.rotate(i)).updateMask(directions.eq(2*i+2)));
    dir_var = dir_var.addBands(img.reduceNeighborhood(ee.Reducer.variance(), diag_kernel.rotate(i)).updateMask(directions.eq(2*i+2)));
  }

  // "collapse" the stack into a single band image (due to masking, each pixel has just one value in it's directional band, and is otherwise masked)
  dir_mean = dir_mean.reduce(ee.Reducer.sum());
  dir_var = dir_var.reduce(ee.Reducer.sum());

  // A finally generate the filtered value
  var varX = dir_var.subtract(dir_mean.multiply(dir_mean).multiply(sigmaV)).divide(sigmaV.add(1.0));

  var b = varX.divide(dir_var);

  var result = dir_mean.add(b.multiply(img.subtract(dir_mean)));
  return(result.arrayFlatten([['sum']]));
}
